# hash table
- 검색트리와 같이 dynamic set을 구현하기 위한 방법 중 하나
- 해시함수: 배열에 key를 저장할 때 index = h(key) 방식으로 저장
- 상수시간. O(1), 배열의 크기에 상관없이 탐색 시간이 같다
- hash table = 해시함수 + 배열
- 탐색을 할 필요가 없다. 따라서 엄청 빠르다
- key, value 를 갖는다
- 해시테이블: 배열에 특정한 키와 관련된 값을 저장
- 해시함수: 값을 어디에 넣을 지 인덱스 숫자를 출력

## 사용 예
- 조회
- 중복 방지
- 서버에게 작업을 시키지 않고 자료를 캐싱

## 충돌 발생 시 대처해야 한다
- 두개 이상의 키가 동일한 위치로 해싱되는 경우
- 사용률이 낮아야 빈 공간이 많아서 충돌이 감소한다 (사용률이 높아지면 리사이징해서 배열의 크기를 증가시켜야 한다)
- 좋은 해시 함수(뭉쳐있지 않고 빈 공간에 골고루 분포 되도록)

### 1. chaining
- 배열의 원소 타입을 연결리스트 형태로 만들어서 하나의 인덱스에 여러 개의 키를 담을 수 있다
- 키가 배열의 인덱스에 골고루 분배되어야 성능이 개선된다.

### 2. open addressing
- linear probing: 충돌 시 다음으로 비어있는 인덱스를 찾아서 넣기. 따라서 인접한 인덱스들에 키가몰려들어서 단점
- 삭제 시 삭제한 인덱스에 인접한 키를 옮겨 놓아야 성능이 개선된다

## 해시함수를 만드는 방법들
- division 기법: h(k) = k % m
- multiplication: 0<A<1, (k*A 의 소수부분) * m 의 소수점 아래 버림
