# 재귀(순환)
- 함수가 스스로를 호출하는 것
- 반복적인 작업을 할 때 유용

## 무란 루프에 빠지지 않기 위한 조건
- base case: recursion에 빠지지 않는 적어도 하나의 경우가 존재해야 한다
- recursive case: 반복하다가 결국 base case로 수렴해야 한다

## 수학적 귀납법 논리구조로 증명하면 된다

### 팩토리얼
- 0! = 1
- n! = n * (n-1)!

### 피보나치 수열
- f(0) = 0
- f(1) = 1
- n > 1 일 때, f(n) = f(n-1) + f(n-2)

### m, n 의 최대공약수
- n = 0 일 때, gcd(m n) = m, 그렇지 않으면 gcd(m, n) = gcd(n, m % n)

## 호출 스택
- push, pop 연산만 가능
- 여러 개의 함수를 호출하면서 함수에 사용되는 변수를 저장
- 재귀를 사용할 때에 함수 호출 정보가 스택에 저장되므로 메모리를 많이 소비한다. 이를 해결하기 위해서 반복문을 사용할 수도 있다

## 모든 반복문을 순환함수로 바꿀 수 있다
- 재귀는 반복문에 비해 성능이 떨어지나, 문제를 명확하게 하는 장점이 있다.

## 암시적 매개변수를 명시적 매개변수로 바꿔라
- 반복문에서와 달리 재귀함수는 자기 자신을 내부에서 호출해야하기 때문에 base case에서 처음 호출하는 경우의 매개변수만 생각할 것이 아니라 recursive case에서 호출할 때의 매개변수도 고려해서 일반화하여 설계해야 한다.

## 미로찾기
- 현재 위치가 벽이거나 이미 방문한 셀이면 false
- 현재 위치가 출구이면 true
- 아니면 현재위치를 방문한 셀이라고 마크 한 후, 사방의 이웃한 셀에 대해 재귀

## 현재 픽셀이 속한 Blob의 크기 세기
- 현재 픽셀이 이미지칼라가 아니라면 return 0
- 이미지 칼라라면, 현재 픽셀을 카운트하고 다른 색으로 칠하고, 이웃한 픽셀에 대하여 재귀

## N Queens Problem
- back tracking: 상태 공간 트리(모든 경우의 수를 포함)를 깊이 우선 방식으로 탐색하여 해를 찾는 방법
- 현재 위치가 더 볼 필요도 없는 꽝이라면(현재의 말이 이전 말들과 열이 겹치는게 있는지, 대각선관계가 있는지 비교) return false
- 현재위치가 마지막 단계의 노드라면 최종적인 답이므로 return true
- 아니라면 다음 단계의 말을 각각의 열에 놓은 후 재귀 호출

## 멱집합: 모든 부분집합을 나열해 보세요 = S의 멱집합을 구한후 각각의 집합에 P를 합집합하여 출력하라(이렇게 문제를 변환하는 이유는 a를 제외한 모든 집합을 반환하고 여기에 a를 추가한 집합을 최종적으로 반환해야 하는데 반환을 두번 할 수는 없으므로 변환함)
- P는 공집합이고 s는 전체집합이라면 S를 반환
- 아니먄 임의의 첫 원소 t 를 제외한 모든 부분집합과
- 위의 부분집합에 t를 추가한 집합의 합집합을 반환

## 상태공간 트리
- 순환함수를 이해하는 데 중요한 도구