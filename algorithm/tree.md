# 트리
- 계층적인 구조를 표현
- 임의의 두 노드간의 경로는 유일하다

## 이진 트리
- 각 노드가 최대 2개의 자식을 갖는다
- 자신이 부모의 왼쪽자식인지 오른쪽 자식인지 지정됨
- 일반적인 이진트리는 인덱스 순서가 보장되지 않으므로 링크드 리스트로 표현 가능
- full or complete 이진트리는 인덱스 순서가 보장되므로 1차원 배열로 표현 가능

### 이진트리의 순회
- inorder: T(l), Root, T(r) 로 구분한 후 왼쪽 서브트리를 순회하고 나서 루트를 순회하고 오른쪽 서브트리를 순회한다 (recursive)
- level order: 레벨 순으로 방문. 동일 레벨에서는 왼쪽에서 오른쪽으로 (큐를 사용해서 구현. 큐에 동일 레벨의 노드들을 넣고 순서대로 빼면서 자식 노드를 출력)

---

# 검색트리
- 계층적 관계의 데이터가 아니지만, dynamic set에서 연산을 효율적으로 지원하기 위해 트리 형태로 구현
- search, insert, delete 연산이 트리의 높이에 비례하는 시간 복잡도를 갖는다

## 1. 이진 검색 트리
- 각 노드의 1개의 키를 갖는다
- 힙은 부모가 자식보다 크거나 같았지만, 이진검색트리는 부모가 왼쪽 자식보다 크고 오른쪽 자식보다 작다

### search
- 찾는 값이 임의의 노드를 기준으로 작은지 큰지 비교해서 왼쪽을 검색할지 오른쪽을 검색할지 판단이 가능 (recursive)
- 최소값: 왼쪽 자식이 존재하지 않을 때까지 왼쪽으로 내려감
- successor: 나보다 큰 수 중에 가장 작은 값. 오른쪽 서브트리에서 최소값 찾기. 만약 오른쪽 서브트리가 없는 경우라면 위로 타고 올라가면서 처음 만나는 왼쪽 링크. successor는 왼쪽 자식이 없다.

### insert
- 루트에서부터 비교하면서 노드를 기준으로 큰지 작은지 판별해서 적당한 자리에 삽입

### delete
- 자식이 없는 경우: 그냥 삭제
- 자식이 1개인 경우: 자식 노드를 자신의 위치로 이동 
- 자식이 2개인 경우: 해당 노드 자체를 삭제하지 말고 데이터만 삭제한 후, successor를 찾아서 그 노드의 데이터를 가져온다. successor는 왼쪽 자식이 없다는 것이 보장되므로 자식이 없거나 1개이므로 노드를 삭제하기 편하다

